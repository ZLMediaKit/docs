import{a as p,b as o,_ as u,c as m}from"./gb28181_push_streaming_4-BtAS7l2e.js";import{_ as g}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as l,o as f,c as b,e as d,a as r,b as i,d as t,w as n}from"./app-CRnFokh3.js";const v={},k={href:"https://github.com/xia-chu/ZLMediaKit/issues/267",target:"_blank",rel:"noopener noreferrer"},h={href:"https://github.com/ZLMediaKit/ZLMediaKit/issues/961",target:"_blank",rel:"noopener noreferrer"},x={href:"https://github.com/ZLMediaKit/ZLMediaKit/issues/1221",target:"_blank",rel:"noopener noreferrer"},L={href:"https://notemi.cn/wvp---zlmedia-kit---mediaserverui-to-realize-streaming-playback-and-recording-of-camera-gb28181.html",target:"_blank",rel:"noopener noreferrer"},M={href:"http://dlgcy.com/gb28181-solution-zlmediakit-mediaserverui/",target:"_blank",rel:"noopener noreferrer"},K={href:"https://github.com/ZLMediaKit/ZLMediaKit/issues/2217",target:"_blank",rel:"noopener noreferrer"};function Z(z,e){const s=l("RouterLink"),a=l("ExternalLinkIcon");return f(),b("div",null,[e[24]||(e[24]=d(`<h2 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍" aria-hidden="true">#</a> 介绍</h2><p>ZLMediaKit 支持 GB28181 的 ps-rtp 推流，支持的编码格式分别为 <code>h264/h265/aac/g711/opus</code>。 在收到 GB28181 推流后，ZLMediaKit 会依次做以下事情：</p><ul><li>rtp 排序去重。</li><li>rtp 解析成 ps 或 ts。</li><li>ps 或 ts 解析成<code>h264/h265/aac/g711/opus</code>。</li><li>输入到复用器，生成 rtsp/rtmp/ts/fmp4 等格式，以便转换成其他协议或容器。</li></ul><h2 id="简单使用" tabindex="-1"><a class="header-anchor" href="#简单使用" aria-hidden="true">#</a> 简单使用</h2><p>ZLMediaKit 默认开启 10000 端口用于接收 UDP/TCP 的 GB28181 推流，由于国标推流不好测试，ZLMediaKit 同时也支持 rtp_mpegts 推流，代码会自适应判断是否为 ps 还是 ts。 所以如果大家没有摄像头的情况下，可以用 FFmpeg 简单测试，基本上体验跟国标推流并无二致。</p><ul><li>ffmpeg 推流命令:</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> ffmpeg <span class="token parameter variable">-re</span> <span class="token parameter variable">-i</span> www/record/robot.mp4 <span class="token parameter variable">-vcodec</span> h264 <span class="token parameter variable">-acodec</span> aac <span class="token parameter variable">-f</span> rtp_mpegts rtp://127.0.0.1:10000
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>MediaServer 收到推流后的日志： <img src="`+u+'" alt="图片" loading="lazy"></li></ul>',8)),r("p",null,[e[1]||(e[1]=i("上图中，这个推流的 rtp ssrc 为 BFC2C622(16 进制打印)，这个流的 app 为")),e[2]||(e[2]=r("code",null,"rtp",-1)),e[3]||(e[3]=i(", stream_id 为")),e[4]||(e[4]=r("code",null,"BFC2C622",-1)),e[5]||(e[5]=i("，您可以根据")),t(s,{to:"/zh/guide/media_server/play_url_rules.html"},{default:n(()=>e[0]||(e[0]=[i("wiki")])),_:1}),e[6]||(e[6]=i("来组合成 url 并播放这个流。"))]),e[25]||(e[25]=r("p",null,"需要指出的是，国标推流的 app 固定为 rtp，你只能通过代码来修改它，stream_id 为 rtp 流的 ssrc，这个是随机的，在 FFmpeg 中貌似没法控制。",-1)),r("p",null,[e[8]||(e[8]=i("另外，每次推流时，请更换 ssrc，否则 ZLMediaKit 发现推流端 ip 和端口变化后，会直接丢弃 rtp 包(现象如此")),r("a",k,[e[7]||(e[7]=i("issue")),t(a)]),e[9]||(e[9]=i(")；这样做的目的是为了防止两个设备使用同一个 ssrc 推流时互相干扰。"))]),e[26]||(e[26]=r("h2",{id:"高阶使用",tabindex:"-1"},[r("a",{class:"header-anchor",href:"#高阶使用","aria-hidden":"true"},"#"),i(" 高阶使用")],-1)),e[27]||(e[27]=r("p",null,"在推流给 10000 端口时，您可能发现有个缺陷，就是 stream_id 是 ssrc，比较抽象，可能还没法控制。",-1)),r("p",null,[e[11]||(e[11]=i("那么我们能否自定义 stream_id? 答案是肯定的，ZLMediaKit 通过")),t(s,{to:"/zh/guide/media_server/restful_api.html#24indexapiopenrtpserver"},{default:n(()=>e[10]||(e[10]=[i("restful api")])),_:1}),e[12]||(e[12]=i("可以动态开启国标收流端口(同时支持 udp/tcp 模式)。"))]),e[28]||(e[28]=d(`<p>在使用 openRtpServer 接口动态开启国标收流端口后，这个端口只能产生一个流，也就是说，一个摄像头需要一个服务器端口用于接收国标推流。</p><ul><li>以下是演示范例(postman 工具调用 openRtpServer 接口创建随机端口)：</li></ul><figure><img src="https://user-images.githubusercontent.com/11495632/93871851-e232dc00-fd01-11ea-8802-b8e91e5f6de1.png" alt="图片" width="1631" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><ul><li>然后启动 FFmpeg 推流</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> ffmpeg <span class="token parameter variable">-re</span> <span class="token parameter variable">-i</span> www/record/robot.mp4 <span class="token parameter variable">-vcodec</span> h264 <span class="token parameter variable">-acodec</span> aac <span class="token parameter variable">-f</span> rtp_mpegts rtp://127.0.0.1:50077
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><p>以下是推流后注册的服务器日志 <img src="`+m+'" alt="图片" loading="lazy"></p></li><li><p>需要指出的是，如果 openRtpServer 接口创建的端口一直没收到流（或者解析不出流），那么会自动关闭和释放。</p></li></ul><h2 id="调试文件生成" tabindex="-1"><a class="header-anchor" href="#调试文件生成" aria-hidden="true">#</a> 调试文件生成</h2><p>如果你的 MediaServer 能收到国标推流，但是未出现<code>媒体注册</code>相关日志，那么有可能是流有些异常，你可以修改配置文件<code>rtp_proxy.dumpDir</code>指定调试文件导出目录， 这样 ZLMediaKit 会把国标流导出到该文件夹，就像这样：</p><figure><img src="https://user-images.githubusercontent.com/11495632/93872911-6c2f7480-fd03-11ea-85d4-911d6d998c83.png" alt="图片" width="631" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>你可以直接用 ffplay 播放<code>mp2/video后缀的文件</code>，<code>rtp</code>后缀的文件，你可以用测试工具<code>test_rtp</code>调试，或者你可以把它分享给其他人帮你分析原因。</p><h2 id="让-zlmediakit-往其他国标服务器推流" tabindex="-1"><a class="header-anchor" href="#让-zlmediakit-往其他国标服务器推流" aria-hidden="true">#</a> 让 ZLMediaKit 往其他国标服务器推流</h2>',11)),r("p",null,[e[14]||(e[14]=i("你可以使用")),t(s,{to:"/zh/guide/media_server/restful_api.html#27indexapistartsendrtp"},{default:n(()=>e[13]||(e[13]=[i("restful api")])),_:1}),e[15]||(e[15]=i("让 ZLMediaKit 生成国标流并往其他服务器推送，支持其他任何已注册的流转国标流。"))]),e[29]||(e[29]=r("ul",null,[r("li",null,"postman 调用 startSendRtp 接口推送国标流：")],-1)),e[30]||(e[30]=r("figure",null,[r("img",{src:"https://user-images.githubusercontent.com/11495632/93873636-a0576500-fd04-11ea-8b0f-98fb3f60c778.png",alt:"图片",width:"1551",tabindex:"0",loading:"lazy"}),r("figcaption",null,"图片")],-1)),e[31]||(e[31]=r("figure",null,[r("img",{src:p,alt:"图片",tabindex:"0",loading:"lazy"}),r("figcaption",null,"图片")],-1)),e[32]||(e[32]=r("ul",null,[r("li",null,"上图中是推送国标流给自己，当然你也可以推送给其他服务器，支持 udp/tcp 方式推流。")],-1)),e[33]||(e[33]=r("h2",{id:"性能",tabindex:"-1"},[r("a",{class:"header-anchor",href:"#性能","aria-hidden":"true"},"#"),i(" 性能")],-1)),r("p",null,[e[17]||(e[17]=i("GB28181 的推流性能测试，请参考：")),r("a",h,[e[16]||(e[16]=i("#961")),t(a)])]),e[34]||(e[34]=r("h2",{id:"丢包问题调试",tabindex:"-1"},[r("a",{class:"header-anchor",href:"#丢包问题调试","aria-hidden":"true"},"#"),i(" 丢包问题调试")],-1)),e[35]||(e[35]=r("p",null,"如果在测试 GB28181 UDP 推流时，频繁打印以下日志:",-1)),e[36]||(e[36]=r("figure",null,[r("img",{src:o,alt:"图片",tabindex:"0",loading:"lazy"}),r("figcaption",null,"图片")],-1)),r("p",null,[e[19]||(e[19]=i("请查看此")),r("a",x,[e[18]||(e[18]=i("issue")),t(a)]),e[20]||(e[20]=i(",特别提示,wifi 情况下,由于无线网络干扰严重，丢包问题很可能确实是网络质量差导致的。"))]),e[37]||(e[37]=r("h2",{id:"相关文章推荐阅读",tabindex:"-1"},[r("a",{class:"header-anchor",href:"#相关文章推荐阅读","aria-hidden":"true"},"#"),i(" 相关文章推荐阅读")],-1)),r("p",null,[r("a",L,[e[21]||(e[21]=i("WVP+ZLMediaKit+MediaServerUI 实现摄像头 GB28181 推流播放录制")),t(a)])]),r("p",null,[r("a",M,[e[22]||(e[22]=i("使用 GB28181.Solution + ZLMediaKit + MediaServerUI 进行摄像头推流和播放")),t(a)])]),r("p",null,[r("a",K,[e[23]||(e[23]=i("GB28181 语音对讲")),t(a)])])])}const S=g(v,[["render",Z],["__file","push_streaming.html.vue"]]);export{S as default};
