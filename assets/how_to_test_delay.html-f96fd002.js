import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as d,c as p,a as e,d as t,b as a,w as s,e as o}from"./app-ceaceb0e.js";const c={},h=o('<h2 id="引言" tabindex="-1"><a class="header-anchor" href="#引言" aria-hidden="true">#</a> 引言</h2><p>有些小伙伴们经常在群里面问我，为什么用ZLMediaKit拉流代理、推流转发的流播放延时好几秒，长的时候10多秒？为什么HLS延时更高，动辄延时半分钟？本文的目的在于澄清大家对延时的误解。</p><h2 id="什么是延时" tabindex="-1"><a class="header-anchor" href="#什么是延时" aria-hidden="true">#</a> 什么是延时</h2><p>很多小伙伴们并不能明白什么叫延时，认为随便一个播放器播放出来的画面跟原始流画面时间差就是延时，其实这是对延时最大的误解。<br> 延时不是表象，很多人在测试延时时很不专业，对延时测试的专业性认识不足，在此我特别提醒，不是随随便便的播放器都有资格做延时测试的!</p><p>总而言之，一般整个延时有以下几部分累加组成：</p><ul><li><strong>采集延时</strong></li></ul><p>在采集摄像头或显卡画面时，由于fps的限制和cpu性能、内存拷贝速度等客观限制，采集画面成YUV/RGB等数据时会有一定的延时，一般延时为毫秒级别。由于一般编码器对输入数据格式存在限制，譬如要求统一输入YUV420P，这样在做RGB-&gt;YUV420P转换时，也会有转换计算延时(这个可以通过libyuv库来降低)。总而言之，采集延时大概为毫秒级别，如果fps为30，那么一般采集延时会有30毫秒以上的延时，在内存拷贝和颜色转换时，又可能增加若干毫秒的延时。</p><ul><li><strong>编码延时</strong></li></ul><p>在把原始画面输入到编码器时，并不会立即输出编码后的数据，特别是在开启B帧时，由于需要参考后面的P帧，那么延时会更大，所以延时敏感的情况下一般不开启B帧，这种情况下编码延时应该是毫秒级别，不是很大。</p><ul><li><strong>网络上行传输延时</strong></li></ul><p>编码后的数据，要经过一定的协议打包才能写入socket，然后传输给推流服务器或拉流代理服务器，协议打包会有一定的内存拷贝和计算量，那么会增加延时，不过这个延时很小，基本忽略不计。数据在上传到服务器时，这个延时可大可小，取决于网络质量。</p><ul><li><strong>服务器转协议延时</strong></li></ul><p>服务器在收到数据后，要读socket缓存、协议解析、解复用、重新打包等操作，不过总体而言，这个延时比较小，基本没什么影响。有时，服务器为了提高性能，会采取合并写的机制，也就是收到一定量的数据后才会一并转发，这个延时一般为几百毫秒，ZLMediaKit默认300毫秒左右，不过ZLMediaKit默认关闭合并写，也就是这个延时也很小。</p><ul><li><strong>网络下行延时</strong></li></ul><p>流媒体在把视频数据转发给播放器时，会存在网络发送，这个延时大小取决于网络质量，ZLMediaKit在关闭低延时模式时，还会增加MSG_MORE和关闭TCP_NODELAY导致的延时，不过ZLMediaKit默认开启低延时模式。</p><ul><li><strong>播放器延时</strong></li></ul><p>播放器延时主要有网络接收延时、协议解析解复用延时、解码延时、缓存延时、渲染延时组成，这些延时中<strong>缓存延时</strong>最大，因为一般的播放器为了保证在网络抖动情况下视频播放的流畅性，会以增加延时为代价，增加播放缓存，这样在网络变差时，不至于播放缓冲卡顿。而且为了音视频同步，也必须确保一定的缓存量。这种延时一般都是秒级别，一般5秒左右。</p><ul><li><strong>播放器GOP缓存延时</strong></li></ul><p>流媒体服务器为了能让播放器立即出画面，往往会缓存最近的一个I帧，这个I帧往后的所有音视频数据被称作为GOP缓存。如果不缓存GOP，那么播放器要等下一个I帧才能解码成功或不花屏，显然为了提高播放体验，这个GOP缓存是不能去掉的。而一般GOP短则1~3秒，长则10几秒，这个跟采集端编码器设置有关，服务器改变不了。但是由于一般的播放器收到缓存后，并不会丢弃过多的画面来确保低延时。况且播放器还希望有一定的缓存来确保播放的流畅性，所以这个GOP缓存将会增大播放器的延时。</p><ul><li><strong>综合延时</strong></li></ul><p>以上所有的延时累加，就是你观看到的直观延时，那么你看到的延时很高，能怪是服务器的问题吗？在理想的网络状况下，你观看到的直观延时，其实约等于播放器的播放缓存延时，这个锅得由播放器来背。</p><h2 id="怎么测试延时" tabindex="-1"><a class="header-anchor" href="#怎么测试延时" aria-hidden="true">#</a> 怎么测试延时</h2><p>用vlc等通用播放器测试延时是很不专业的，这些播放器延时最少是秒级别的，为了播放流畅度和音视频同步，这些播放器是不可能给你真实的延时数据。</p>',23),_=e("br",null,null,-1),u={href:"https://github.com/ZLMediaKit/ZLMediaKit/blob/master/player/test_player.cpp",target:"_blank",rel:"noopener noreferrer"},f=o(`<p>什么？ 你告诉我你不会编译ZLMediaKit？ 那好，退而求其次，我推荐你使用webrtc播放来测试zlm延时；也可以用ffplay测试：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>ffplay <span class="token parameter variable">-i</span> rtmp://xxxxxxx <span class="token parameter variable">-fflags</span> nobuffer
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,2),g={href:"http://ffmpeg.org/download.html",target:"_blank",rel:"noopener noreferrer"},m=e("h2",{id:"关于延时的更多信息",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#关于延时的更多信息","aria-hidden":"true"},"#"),t(" 关于延时的更多信息")],-1);function b(x,L){const r=n("ExternalLinkIcon"),l=n("RouterLink");return d(),p("div",null,[h,e("p",null,[t("在此，我强烈推荐大家自己写个无缓存的播放器测试延时，但是这显然超过了大部人的能力，所以ZLMediaKit提供了一个简单的播放器测试延时："),_,e("a",u,[t("test_player"),a(r)])]),f,e("p",null,[t("如果你不知道ffplay怎么安装，你可以从"),e("a",g,[t("这里"),a(r)]),t("下载编译好的.")]),m,e("p",null,[a(l,{to:"/zh/reference/documents/the_nature_of_live_broadcast_delay.html"},{default:s(()=>[t("直播延时的本质")]),_:1})]),e("p",null,[a(l,{to:"/zh/reference/test/delay_test.html"},{default:s(()=>[t("延时相关测试")]),_:1})])])}const y=i(c,[["render",b],["__file","how_to_test_delay.html.vue"]]);export{y as default};
