import{_ as r}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as l,c as s,o,a as i,b as d,e as t,d as n}from"./app-D6CC-_aF.js";const g={},p={href:"https://github.com/xiongziliang/ZLMediaKit/commit/b169f94cce1ecbab50248f25ee3b33dd40602fe1",target:"_blank",rel:"noopener noreferrer"},u={href:"https://github.com/xiongziliang/ZLMediaKit/blob/master/tests/test_benchmark.cpp",target:"_blank",rel:"noopener noreferrer"},m={href:"https://github.com/xiongziliang/ZLMediaKit/tree/master/server",target:"_blank",rel:"noopener noreferrer"};function b(f,e){const a=l("ExternalLinkIcon");return o(),s("div",null,[e[14]||(e[14]=i("h2",{id:"概述",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#概述","aria-hidden":"true"},"#"),t(" 概述")],-1)),i("p",null,[e[1]||(e[1]=t("在最近 ZLMediaKit 的一次提交中，我对 rtsp 服务器的性能做了一次")),i("a",p,[e[0]||(e[0]=t("改进")),n(a)]),e[2]||(e[2]=t(",本次改进中，核心的思想是："))]),e[15]||(e[15]=i("ul",null,[i("li",null,[i("strong",null,"缓存时间戳相同的 RTP 包(意味着是同一帧数据)，作为一个数据包进行分发"),t("。")])],-1)),e[16]||(e[16]=i("p",null,[t("理论上，这样做可以大大"),i("strong",null,"减少多线程分发时线程切换次数、多余发送逻辑代码的执行以及系统调用次数"),t("，预期在不增加播放延时的情况下能大幅提高 rtsp 服务器的性能.")],-1)),e[17]||(e[17]=i("h2",{id:"测试",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#测试","aria-hidden":"true"},"#"),t(" 测试")],-1)),e[18]||(e[18]=i("p",null,"为了验证本次优化的预期目标，我在 linux 服务器上做了一系列的测试对比，以下是测试环境：",-1)),i("ul",null,[e[7]||(e[7]=i("li",null,"操作系统：ubuntu16 desktop 64bit",-1)),e[8]||(e[8]=i("li",null,"cpu： 4 核心的 Intel(R) Core(TM) i7-4790 CPU @ 3.60GHz",-1)),e[9]||(e[9]=i("li",null,"编译器：gcc 5.4.0，开启 Release 编译(cmake -DCMAKE_BUILD_TYPE=Release)",-1)),e[10]||(e[10]=i("li",null,"malloc 库：连接 jemalloc",-1)),e[11]||(e[11]=i("li",null,"网络： 127.0.0.1 本地循环网络",-1)),i("li",null,[e[4]||(e[4]=t("测试客户端：")),i("a",u,[e[3]||(e[3]=t("test_benchmark")),n(a)])]),i("li",null,[e[6]||(e[6]=t("测试服务器：")),i("a",m,[e[5]||(e[5]=t("MediaServer")),n(a)])]),e[12]||(e[12]=i("li",null,"测试码流：4K H264 的 RTSP 流，通过 MP4 Rtsp 点播实现，文件 200 秒，190MB,码流大概 8Mb/s",-1)),e[13]||(e[13]=i("li",null,"测试方法：通过 test_benchmark 播放 500 路 RTSP 4K 点播，总码流大概 4Gb/s，分别测试新老版本的 MediaServer 的进程。",-1))]),e[19]||(e[19]=d('<h2 id="测试数据" tabindex="-1"><a class="header-anchor" href="#测试数据" aria-hidden="true">#</a> 测试数据</h2><ul><li>启动的播放器个数： <img src="https://user-images.githubusercontent.com/11495632/78686734-f6d31180-7925-11ea-9ba3-864865a910b9.png" alt="image" loading="lazy"></li><li>实时码流: <img src="https://user-images.githubusercontent.com/11495632/78686849-1b2eee00-7926-11ea-9434-a4f943021be5.png" alt="image" loading="lazy"></li></ul><h2 id="性能对比" tabindex="-1"><a class="header-anchor" href="#性能对比" aria-hidden="true">#</a> 性能对比</h2><h3 id="老版本数据" tabindex="-1"><a class="header-anchor" href="#老版本数据" aria-hidden="true">#</a> 老版本数据</h3><ul><li><p>cpu 使用率(浮动比较大，最高 200%+)：</p><p><img src="https://user-images.githubusercontent.com/11495632/78687097-621ce380-7926-11ea-9adb-80ccbbfca1f3.png" alt="image" loading="lazy"><img src="https://user-images.githubusercontent.com/11495632/78687391-b031e700-7926-11ea-9b81-0339d8d9dafd.png" alt="image" loading="lazy"></p></li><li><p>性能分析(perf top)：</p><figure><img src="https://user-images.githubusercontent.com/11495632/78687480-c8096b00-7926-11ea-9d72-f21fffa8fd7d.png" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure></li><li><p>总结： cpu 占用主要发生在内核态的系统调用(syscall)、tcp_sendmsg、内存拷贝。</p></li></ul><h3 id="新版本数据" tabindex="-1"><a class="header-anchor" href="#新版本数据" aria-hidden="true">#</a> 新版本数据</h3><ul><li><p>cpu 使用率(浮动比较小，50%以下)：</p><p><img src="https://user-images.githubusercontent.com/11495632/78688226-9e9d0f00-7927-11ea-8d31-49d487f339b4.png" alt="image" loading="lazy"><img src="https://user-images.githubusercontent.com/11495632/78687893-3b12e180-7927-11ea-9e41-653b771405de.png" alt="image" loading="lazy"></p></li><li><p>后面我又测试了 2000 个播放器，掉了一批，最后稳定在 1800 个左右，实时流量 17.5Gb/s(单向)左右,cpu 占用 300%左右:</p><p><img src="https://user-images.githubusercontent.com/11495632/78741558-39c7d000-798c-11ea-9860-6dc18db1ef0c.png" alt="image" loading="lazy"><img src="https://user-images.githubusercontent.com/11495632/78741649-78f62100-798c-11ea-85a9-1810bf1deaf1.png" alt="image" loading="lazy"><img src="https://user-images.githubusercontent.com/11495632/78741678-8d3a1e00-798c-11ea-9aec-dff834620781.png" alt="image" loading="lazy"><img src="https://user-images.githubusercontent.com/11495632/78741720-ad69dd00-798c-11ea-83c6-1b0b57d79ba2.png" alt="image" loading="lazy"></p></li><li><p>性能分析(perf top)：</p><figure><img src="https://user-images.githubusercontent.com/11495632/78688104-7a413280-7927-11ea-953b-d3b9a4c5ed0c.png" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure></li><li><p>总结：cpu 占用主要发生在内核态内存拷贝，系统调用(syscall)、tcp_sendmsg 的开销很小。</p></li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>本次性能测试基本证明了预想，性能提升大概有 4 倍以上。 本机器为 i7-4790 4 核心 8 线程的，所以 cpu 占用率最高为 800%，现在 ZLMediaKit 在上面支撑 500 个 4K RTSP 播放器，实时流量大概 4Gb/s 时 cpu 使用率 50%不到,通过简单换算，该 cpu 可以支撑大概 8000 个 4K RTSP 播放器，实时流量最高能达到 64Gb/s，考虑到性能折损，我们保守估计可以支持 6000 个 4K RTSP 播放器，50Gb/s 的流量。</p><h2 id="最后" tabindex="-1"><a class="header-anchor" href="#最后" aria-hidden="true">#</a> 最后</h2><p>在 ZLMediaKit 流媒体服务器中，通过智能指针引用计数的方式实现了多线程的数据分发，不管分发多少次，数据拷贝次数都是固定的，所以 ZLMediaKit 可以达到如此夸张的性能参数，但是在测试中，我们也能发现，性能占用已经大部分发生在内核态了，应用层的 cpu 占用反而不是瓶颈了。这是因为在内核态，写 socket 缓存需要做内存拷贝，随着播放器个数的增加，内存拷贝会越来越多，此时性能瓶颈不再是应用层，而是由于内存带宽瓶颈导致的内核性能瓶颈。</p>',11))])}const x=r(g,[["render",b],["__file","rtsp_performance_optimization.html.vue"]]);export{x as default};
