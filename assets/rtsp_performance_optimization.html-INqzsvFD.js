import{_ as n}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as s,o as r,c as l,a as e,d as a,b as i,e as c}from"./app-RP31lnfq.js";const o={},d=e("h2",{id:"概述",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#概述","aria-hidden":"true"},"#"),a(" 概述")],-1),h={href:"https://github.com/xiongziliang/ZLMediaKit/commit/b169f94cce1ecbab50248f25ee3b33dd40602fe1",target:"_blank",rel:"noopener noreferrer"},g=e("ul",null,[e("li",null,[e("strong",null,"缓存时间戳相同的 RTP 包(意味着是同一帧数据)，作为一个数据包进行分发"),a("。")])],-1),p=e("p",null,[a("理论上，这样做可以大大"),e("strong",null,"减少多线程分发时线程切换次数、多余发送逻辑代码的执行以及系统调用次数"),a("，预期在不增加播放延时的情况下能大幅提高 rtsp 服务器的性能.")],-1),u=e("h2",{id:"测试",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#测试","aria-hidden":"true"},"#"),a(" 测试")],-1),m=e("p",null,"为了验证本次优化的预期目标，我在 linux 服务器上做了一系列的测试对比，以下是测试环境：",-1),b=e("li",null,"操作系统：ubuntu16 desktop 64bit",-1),_=e("li",null,"cpu： 4 核心的 Intel(R) Core(TM) i7-4790 CPU @ 3.60GHz",-1),f=e("li",null,"编译器：gcc 5.4.0，开启 Release 编译(cmake -DCMAKE_BUILD_TYPE=Release)",-1),x=e("li",null,"malloc 库：连接 jemalloc",-1),z=e("li",null,"网络： 127.0.0.1 本地循环网络",-1),y={href:"https://github.com/xiongziliang/ZLMediaKit/blob/master/tests/test_benchmark.cpp",target:"_blank",rel:"noopener noreferrer"},M={href:"https://github.com/xiongziliang/ZLMediaKit/tree/master/server",target:"_blank",rel:"noopener noreferrer"},k=e("li",null,"测试码流：4K H264 的 RTSP 流，通过 MP4 Rtsp 点播实现，文件 200 秒，190MB,码流大概 8Mb/s",-1),K=e("li",null,"测试方法：通过 test_benchmark 播放 500 路 RTSP 4K 点播，总码流大概 4Gb/s，分别测试新老版本的 MediaServer 的进程。",-1),L=c('<h2 id="测试数据" tabindex="-1"><a class="header-anchor" href="#测试数据" aria-hidden="true">#</a> 测试数据</h2><ul><li>启动的播放器个数： <img src="https://user-images.githubusercontent.com/11495632/78686734-f6d31180-7925-11ea-9ba3-864865a910b9.png" alt="image" loading="lazy"></li><li>实时码流: <img src="https://user-images.githubusercontent.com/11495632/78686849-1b2eee00-7926-11ea-9434-a4f943021be5.png" alt="image" loading="lazy"></li></ul><h2 id="性能对比" tabindex="-1"><a class="header-anchor" href="#性能对比" aria-hidden="true">#</a> 性能对比</h2><h3 id="老版本数据" tabindex="-1"><a class="header-anchor" href="#老版本数据" aria-hidden="true">#</a> 老版本数据</h3><ul><li><p>cpu 使用率(浮动比较大，最高 200%+)：</p><p><img src="https://user-images.githubusercontent.com/11495632/78687097-621ce380-7926-11ea-9adb-80ccbbfca1f3.png" alt="image" loading="lazy"><img src="https://user-images.githubusercontent.com/11495632/78687391-b031e700-7926-11ea-9b81-0339d8d9dafd.png" alt="image" loading="lazy"></p></li><li><p>性能分析(perf top)：</p><figure><img src="https://user-images.githubusercontent.com/11495632/78687480-c8096b00-7926-11ea-9d72-f21fffa8fd7d.png" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure></li><li><p>总结： cpu 占用主要发生在内核态的系统调用(syscall)、tcp_sendmsg、内存拷贝。</p></li></ul><h3 id="新版本数据" tabindex="-1"><a class="header-anchor" href="#新版本数据" aria-hidden="true">#</a> 新版本数据</h3><ul><li><p>cpu 使用率(浮动比较小，50%以下)：</p><p><img src="https://user-images.githubusercontent.com/11495632/78688226-9e9d0f00-7927-11ea-8d31-49d487f339b4.png" alt="image" loading="lazy"><img src="https://user-images.githubusercontent.com/11495632/78687893-3b12e180-7927-11ea-9e41-653b771405de.png" alt="image" loading="lazy"></p></li><li><p>后面我又测试了 2000 个播放器，掉了一批，最后稳定在 1800 个左右，实时流量 17.5Gb/s(单向)左右,cpu 占用 300%左右:</p><p><img src="https://user-images.githubusercontent.com/11495632/78741558-39c7d000-798c-11ea-9860-6dc18db1ef0c.png" alt="image" loading="lazy"><img src="https://user-images.githubusercontent.com/11495632/78741649-78f62100-798c-11ea-85a9-1810bf1deaf1.png" alt="image" loading="lazy"><img src="https://user-images.githubusercontent.com/11495632/78741678-8d3a1e00-798c-11ea-9aec-dff834620781.png" alt="image" loading="lazy"><img src="https://user-images.githubusercontent.com/11495632/78741720-ad69dd00-798c-11ea-83c6-1b0b57d79ba2.png" alt="image" loading="lazy"></p></li><li><p>性能分析(perf top)：</p><figure><img src="https://user-images.githubusercontent.com/11495632/78688104-7a413280-7927-11ea-953b-d3b9a4c5ed0c.png" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure></li><li><p>总结：cpu 占用主要发生在内核态内存拷贝，系统调用(syscall)、tcp_sendmsg 的开销很小。</p></li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>本次性能测试基本证明了预想，性能提升大概有 4 倍以上。 本机器为 i7-4790 4 核心 8 线程的，所以 cpu 占用率最高为 800%，现在 ZLMediaKit 在上面支撑 500 个 4K RTSP 播放器，实时流量大概 4Gb/s 时 cpu 使用率 50%不到,通过简单换算，该 cpu 可以支撑大概 8000 个 4K RTSP 播放器，实时流量最高能达到 64Gb/s，考虑到性能折损，我们保守估计可以支持 6000 个 4K RTSP 播放器，50Gb/s 的流量。</p><h2 id="最后" tabindex="-1"><a class="header-anchor" href="#最后" aria-hidden="true">#</a> 最后</h2><p>在 ZLMediaKit 流媒体服务器中，通过智能指针引用计数的方式实现了多线程的数据分发，不管分发多少次，数据拷贝次数都是固定的，所以 ZLMediaKit 可以达到如此夸张的性能参数，但是在测试中，我们也能发现，性能占用已经大部分发生在内核态了，应用层的 cpu 占用反而不是瓶颈了。这是因为在内核态，写 socket 缓存需要做内存拷贝，随着播放器个数的增加，内存拷贝会越来越多，此时性能瓶颈不再是应用层，而是由于内存带宽瓶颈导致的内核性能瓶颈。</p>',11);function R(P,T){const t=s("ExternalLinkIcon");return r(),l("div",null,[d,e("p",null,[a("在最近 ZLMediaKit 的一次提交中，我对 rtsp 服务器的性能做了一次"),e("a",h,[a("改进"),i(t)]),a(",本次改进中，核心的思想是：")]),g,p,u,m,e("ul",null,[b,_,f,x,z,e("li",null,[a("测试客户端："),e("a",y,[a("test_benchmark"),i(t)])]),e("li",null,[a("测试服务器："),e("a",M,[a("MediaServer"),i(t)])]),k,K]),L])}const v=n(o,[["render",R],["__file","rtsp_performance_optimization.html.vue"]]);export{v as default};
