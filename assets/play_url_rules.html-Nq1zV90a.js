import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o,c as d,e as i}from"./app-RP31lnfq.js";const c={},l=i('<h2 id="_1、url-的组成部分" tabindex="-1"><a class="header-anchor" href="#_1、url-的组成部分" aria-hidden="true">#</a> 1、url 的组成部分</h2><p>以<code>rtsp://somedomain.com:554/live/0?token=abcdefg&amp;field=value</code>为例,该 url 分为以下几个部分：</p><ul><li><code>协议(scheam)</code> : rtsp 协议,默认端口 554</li><li><code>虚拟主机(vhost)</code> : somedomain.com,该字段既可以是域名也可以是 ip，如果是 ip 则对应的虚拟主机为<code>__defaultVhost__</code></li><li><code>服务端口号(port)</code> : 554,如果不指定端口号，则使用协议默认端口号</li><li><code>应用名(app)</code> : live</li><li><code>流ID(streamid)</code> : 0</li><li><code>参数(args)</code> : token=abcdefg&amp;field=value</li></ul><h2 id="_2、zlmediakit-中的流媒体源" tabindex="-1"><a class="header-anchor" href="#_2、zlmediakit-中的流媒体源" aria-hidden="true">#</a> 2、ZLMediaKit 中的流媒体源</h2><p>在 ZLMediaKit 中，流媒体源是一种可以被用于直播转发、推流转发等功能的数据对象，在本项目中被称作为<code>MediaSource</code>，目前支持 5 种类型的流媒体源，分别是<code>RtspMediaSource</code>、<code>RtmpMediaSource</code>、<code>HlsMediaSource</code>、<code>TSMediaSource</code>、<code>FMP4MediaSource</code>。</p><p>定位一个流媒体源，主要通过 4 个元素(我们后续称其为 4 元组)，分别是:</p><ul><li><code>协议(scheam)</code></li><li><code>虚拟主机(vhost)</code></li><li><code>应用名(app)</code></li><li><code>流ID(streamid) </code></li></ul><p><code>RtspMediaSource</code>支持 rtsp 播放、rtsp 推流、webrtc 播放、webrtc 推流。</p><p><code>RtmpMediaSource</code>支持 rtmp 推流/播放、http-flv 播放、ws-flv 播放。</p><p><code>HlsMediaSource</code>支持 hls 播放。</p><p><code>TSMediaSource</code> 支持 http-ts 播放、ws-ts 播放。</p><p><code>FMP4MediaSource</code> 支持 http-fmp4 播放、ws-fmp4 播放。</p><h2 id="_3、流媒体源对应的播放-url" tabindex="-1"><a class="header-anchor" href="#_3、流媒体源对应的播放-url" aria-hidden="true">#</a> 3、流媒体源对应的播放 url</h2><p>假定有一个<code>RtspMediaSource</code>，它的 4 元组分别为 <code>rtsp(RtspMediaSource固定为rtsp)</code>、<code>somedomain.com</code>、<code>live</code>、<code>0</code> 那么播放这个流媒体源的 url 对应为:</p><ul><li><code>rtsp://somedomain.com/live/0</code></li><li><code>rtsps://somedomain.com/live/0</code></li><li><code>rtsp://127.0.0.1/live/0?vhost=somedomain.com</code></li><li><code>rtsps://127.0.0.1/live/0?vhost=somedomain.com</code></li></ul><p>如果有一个<code>RtmpMediaSource</code>，它的 4 元组分别为 <code>rtmp(RtmpMediaSource固定为rtmp)</code>、<code>somedomain.com</code>、<code>live</code>、<code>0</code> 那么播放这个流媒体源的 url 对应为:</p><ul><li><code>rtmp://somedomain.com/live/0</code></li><li><code>rtmps://somedomain.com/live/0</code></li><li><code>rtmp://127.0.0.1/live/0?vhost=somedomain.com</code></li><li><code>rtmps://127.0.0.1/live/0?vhost=somedomain.com</code></li></ul><p>rtmp 类型的流媒体源也支持<code>http-flv</code>、<code>websocket</code>直播，对应的 url 如下：</p><div class="hint-container warning"><p class="hint-container-title">老代码 flv 直播后缀为.flv，新代码才改成了.live.flv</p></div><ul><li><code>http://somedomain.com/live/0.live.flv</code></li><li><code>https://somedomain.com/live/0.live.flv</code></li><li><code>http://127.0.0.1/live/0.live.flv?vhost=somedomain.com</code></li><li><code>https://127.0.0.1/live/0.live.flv?vhost=somedomain.com</code></li><li><code>ws://somedomain.com/live/0.live.flv</code></li><li><code>wss://somedomain.com/live/0.live.flv</code></li><li><code>ws://127.0.0.1/live/0.live.flv?vhost=somedomain.com</code></li><li><code>wss://127.0.0.1/live/0.live.flv?vhost=somedomain.com</code></li></ul><p>当然，ZLMediaKit 一般会把 rtsp、rtmp 流媒体源互相转换，也会转换成 hls/http-ts/ws-ts/http-fmp4/ws-fmp4，播放的 url 如下：</p><ul><li><p>HLS(mpegts)</p><ul><li><code>http://somedomain.com/live/0/hls.m3u8</code></li><li><code>https://somedomain.com/live/0/hls.m3u8</code></li><li><code>http://127.0.0.1/live/0/hls.m3u8?vhost=somedomain.com</code></li><li><code>https://127.0.0.1/live/0/hls.m3u8?vhost=somedomain.com</code></li></ul></li><li><p>HLS(fmp4)</p><ul><li><code>http://somedomain.com/live/0/hls.fmp4.m3u8</code></li><li><code>https://somedomain.com/live/0/hls.fmp4.m3u8</code></li><li><code>http://127.0.0.1/live/0/hls.fmp4.m3u8?vhost=somedomain.com</code></li><li><code>https://127.0.0.1/live/0/hls.fmp4.m3u8?vhost=somedomain.com</code></li></ul></li><li><p>HTTP-TS/WS-TS(后缀为.live.ts,目的是为了解决与 hls 的冲突)</p><ul><li><code>http://somedomain.com/live/0.live.ts</code></li><li><code>https://somedomain.com/live/0.live.ts</code></li><li><code>http://127.0.0.1/live/0.live.ts?vhost=somedomain.com</code></li><li><code>https://127.0.0.1/live/0.live.ts?vhost=somedomain.com</code></li><li><code>ws://somedomain.com/live/0.live.ts</code></li><li><code>wss://somedomain.com/live/0.live.ts</code></li><li><code>ws://127.0.0.1/live/0.live.ts?vhost=somedomain.com</code></li><li><code>wss://127.0.0.1/live/0.live.ts?vhost=somedomain.com</code></li></ul></li><li><p>HTTP-fMP4/WS-fMP4(后缀为.live.mp4,目的是为了解决与 mp4 点播的冲突)</p><ul><li><code>http://somedomain.com/live/0.live.mp4</code></li><li><code>https://somedomain.com/live/0.live.mp4</code></li><li><code>http://127.0.0.1/live/0.live.mp4?vhost=somedomain.com</code></li><li><code>https://127.0.0.1/live/0.live.mp4?vhost=somedomain.com</code></li><li><code>ws://somedomain.com/live/0.live.mp4</code></li><li><code>wss://somedomain.com/live/0.live.mp4</code></li><li><code>ws://127.0.0.1/live/0.live.mp4?vhost=somedomain.com</code></li><li><code>wss://127.0.0.1/live/0.live.mp4?vhost=somedomain.com</code></li></ul></li></ul><p>一般而言，上述 url 在 ZLMediaKit 都有效，因为 ZLMediaKit 默认转换流媒体源。</p><h2 id="_4、点播-url" tabindex="-1"><a class="header-anchor" href="#_4、点播-url" aria-hidden="true">#</a> 4、点播 url</h2><p>ZLMediaKit 的点播一般通过 mp4 文件来实现，推荐大家使用 http mp4 点播，这样是最简单，服务器也无需解复用 mp4 文件，当然 ZLMediaKit 目前也支持 rtsp、rtmp、http-flv、websocket-flv 的 mp4 点播， 对应的 url 跟直播 url 类似，不在赘述，这里只介绍区别。</p><ul><li>ZLMediaKit 对点播限制应用名，默认为<code>record</code></li><li>假如一个 mp4 文件放置在 http 根目录 record 文件夹(<code>www/record</code>)下，他的相对路径为:<code>www/record/0.mp4</code>,那么点播 url 则为: <ul><li><code>rtsp://somedomain.com/record/0.mp4</code></li><li><code>rtmp://somedomain.com/record/0.mp4</code></li><li><code>http://somedomain.com/record/0.mp4</code>(这里是通用的 http 文件点播，服务器不用解复用文件)</li><li><code>http://somedomain.com/record/0.mp4.live.flv</code>（这里是 http-flv 直播，不是 http 点播，服务器需要解复用文件）</li><li><code>ws://somedomain.com/record/0.mp4.live.flv</code></li><li><code>http://somedomain.com/record/0.mp4.live.ts</code>（这里是 http-ts 直播，不是 http 点播，服务器需要解复用文件）</li><li><code>ws://somedomain.com/record/0.mp4.live.ts</code></li><li><code>http://somedomain.com/record/0.mp4.live.mp4</code>（这里是 http-fmp4 直播，不是 http 点播，服务器需要解复用文件）</li><li><code>ws://somedomain.com/record/0.mp4.live.mp4</code></li></ul></li><li>如果开启了虚拟主机，那么点播文件需要放置在 <code>www/somedomain.com/record/0.mp4</code>。</li></ul><h2 id="_5、webrtc-推流-播放" tabindex="-1"><a class="header-anchor" href="#_5、webrtc-推流-播放" aria-hidden="true">#</a> 5、webrtc 推流/播放</h2><p><code>webrtc</code>播放跟上述方式不太一样，webrtc 协议本身不定义信令交互协议，用户自己去实现<code>sdp+icecandidate</code>交换逻辑，所以<code>webrtc</code>并没有一个标准的播放器，需要自己使用 js 或 native sdk 去实现播放。</p><p><code>zlmediakit</code>实现的<code>webrtc sdp+icecandidate</code>交换方式是<code>http post</code>方式，接口名为<code>/index/api/webrtc</code>, 该接口使用 post content 传递 <code>offer sdp</code>, 同时 url query 参数传递媒体源 4 元组中的<code>app</code> <code>steam_id</code>，由于 http 协议本身支持<code>vhost</code>，所以不需要另外指定<code>vhost</code>。 <code>webrtc</code>在<code>zlmediakit</code>中可以认为是 rtsp 协议的另外表现形式，他们推流、播放使用的数据源都相同，都是<code>RtspMediaSource</code>。</p><p>在 webrtc 推流时，交互<code>webrtc sdp+icecandidate</code>的 http post 接口类似为：<code>http://127.0.0.1/index/api/webrtc?app=live&amp;stream=test&amp;type=push</code></p><p>在 webrtc 播放时，交互<code>webrtc sdp+icecandidate</code>的 http post 接口类似为：<code>http://127.0.0.1/index/api/webrtc?app=live&amp;stream=test&amp;type=play</code>。</p><p>zlmeiakit 工程自带 webrtc 测试播放/推流器，用户启动 zlmediakit 后，浏览器访问<code>http://127.0.0.1/webrtc/</code>就可以访问之。</p><p>另外，zlmediakit 也支持使用 webrtc 播放 mp4 文件，http post 接口类似为：<code>http://127.0.0.1/index/api/webrtc?app=record&amp;stream=test.mp4&amp;type=play</code>。</p><h2 id="_6、url-参数" tabindex="-1"><a class="header-anchor" href="#_6、url-参数" aria-hidden="true">#</a> 6、url 参数</h2><p>ZLMediaKit 会识别 url 中问号后面的字符串为 url 参数，其格式跟 http 一致，其中参数<code>vhost</code>是 ZLMediaKit 内置支持的参数，支持指定 vhost。 url 参数主要用于播放、推流鉴权，在触发 hook api 时，会把这些参数提交给第三方业务服务器</p>',35),t=[l];function m(s,p){return o(),d("div",null,t)}const h=e(c,[["render",m],["__file","play_url_rules.html.vue"]]);export{h as default};
