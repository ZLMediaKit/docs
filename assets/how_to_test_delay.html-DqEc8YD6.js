import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,c as d,o as f,b as i,a as t,e as r,d as a,w as l}from"./app-D6CC-_aF.js";const u={},g={href:"https://github.com/ZLMediaKit/ZLMediaKit/blob/master/player/test_player.cpp",target:"_blank",rel:"noopener noreferrer"},h={href:"http://ffmpeg.org/download.html",target:"_blank",rel:"noopener noreferrer"};function m(b,e){const n=o("ExternalLinkIcon"),s=o("RouterLink");return f(),d("div",null,[e[7]||(e[7]=i('<h2 id="引言" tabindex="-1"><a class="header-anchor" href="#引言" aria-hidden="true">#</a> 引言</h2><p>有些小伙伴们经常在群里面问我，为什么用 ZLMediaKit 拉流代理、推流转发的流播放延时好几秒，长的时候 10 多秒？为什么 HLS 延时更高，动辄延时半分钟？本文的目的在于澄清大家对延时的误解。</p><h2 id="什么是延时" tabindex="-1"><a class="header-anchor" href="#什么是延时" aria-hidden="true">#</a> 什么是延时</h2><p>很多小伙伴们并不能明白什么叫延时，认为随便一个播放器播放出来的画面跟原始流画面时间差就是延时，其实这是对延时最大的误解。 延时不是表象，很多人在测试延时时很不专业，对延时测试的专业性认识不足，在此我特别提醒，不是随随便便的播放器都有资格做延时测试的!</p><p>总而言之，一般整个延时有以下几部分累加组成：</p><ul><li><p><strong>采集延时</strong></p><p>在采集摄像头或显卡画面时，由于 fps 的限制和 cpu 性能、内存拷贝速度等客观限制，采集画面成 YUV/RGB 等数据时会有一定的延时，一般延时为毫秒级别。由于一般编码器对输入数据格式存在限制，譬如要求统一输入 YUV420P，这样在做 RGB-&gt;YUV420P 转换时，也会有转换计算延时(这个可以通过 libyuv 库来降低)。总而言之，采集延时大概为毫秒级别，如果 fps 为 30，那么一般采集延时会有 30 毫秒以上的延时，在内存拷贝和颜色转换时，又可能增加若干毫秒的延时。</p></li><li><p><strong>编码延时</strong></p><p>在把原始画面输入到编码器时，并不会立即输出编码后的数据，特别是在开启 B 帧时，由于需要参考后面的 P 帧，那么延时会更大，所以延时敏感的情况下一般不开启 B 帧，这种情况下编码延时应该是毫秒级别，不是很大。</p></li><li><p><strong>网络上行传输延时</strong></p><p>编码后的数据，要经过一定的协议打包才能写入 socket，然后传输给推流服务器或拉流代理服务器，协议打包会有一定的内存拷贝和计算量，那么会增加延时，不过这个延时很小，基本忽略不计。数据在上传到服务器时，这个延时可大可小，取决于网络质量。</p></li><li><p><strong>服务器转协议延时</strong></p><p>服务器在收到数据后，要读 socket 缓存、协议解析、解复用、重新打包等操作，不过总体而言，这个延时比较小，基本没什么影响。有时，服务器为了提高性能，会采取合并写的机制，也就是收到一定量的数据后才会一并转发，这个延时一般为几百毫秒，ZLMediaKit 默认 300 毫秒左右，不过 ZLMediaKit 默认关闭合并写，也就是这个延时也很小。</p></li><li><p><strong>网络下行延时</strong></p><p>流媒体在把视频数据转发给播放器时，会存在网络发送，这个延时大小取决于网络质量，ZLMediaKit 在关闭低延时模式时，还会增加 MSG_MORE 和关闭 TCP_NODELAY 导致的延时，不过 ZLMediaKit 默认开启低延时模式。</p></li><li><p><strong>播放器延时</strong></p><p>播放器延时主要有网络接收延时、协议解析解复用延时、解码延时、缓存延时、渲染延时组成，这些延时中<strong>缓存延时</strong>最大，因为一般的播放器为了保证在网络抖动情况下视频播放的流畅性，会以增加延时为代价，增加播放缓存，这样在网络变差时，不至于播放缓冲卡顿。而且为了音视频同步，也必须确保一定的缓存量。这种延时一般都是秒级别，一般 5 秒左右。</p></li><li><p><strong>播放器 GOP 缓存延时</strong></p><p>流媒体服务器为了能让播放器立即出画面，往往会缓存最近的一个 I 帧，这个 I 帧往后的所有音视频数据被称作为 GOP 缓存。如果不缓存 GOP，那么播放器要等下一个 I 帧才能解码成功或不花屏，显然为了提高播放体验，这个 GOP 缓存是不能去掉的。而一般 GOP 短则 1~3 秒，长则 10 几秒，这个跟采集端编码器设置有关，服务器改变不了。但是由于一般的播放器收到缓存后，并不会丢弃过多的画面来确保低延时。况且播放器还希望有一定的缓存来确保播放的流畅性，所以这个 GOP 缓存将会增大播放器的延时。</p></li><li><p><strong>综合延时</strong></p><p>以上所有的延时累加，就是你观看到的直观延时，那么你看到的延时很高，能怪是服务器的问题吗？在理想的网络状况下，你观看到的直观延时，其实约等于播放器的播放缓存延时，这个锅得由播放器来背。</p></li></ul><h2 id="怎么测试延时" tabindex="-1"><a class="header-anchor" href="#怎么测试延时" aria-hidden="true">#</a> 怎么测试延时</h2><p>用 vlc 等通用播放器测试延时是很不专业的，这些播放器延时最少是秒级别的，为了播放流畅度和音视频同步，这些播放器是不可能给你真实的延时数据。</p>',8)),t("p",null,[e[1]||(e[1]=r("在此，我强烈推荐大家自己写个无缓存的播放器测试延时，但是这显然超过了大部人的能力，所以 ZLMediaKit 提供了一个简单的播放器测试延时： ")),t("a",g,[e[0]||(e[0]=r("test_player")),a(n)])]),e[8]||(e[8]=i(`<p>什么？ 你告诉我你不会编译 ZLMediaKit？ 那好，退而求其次，我推荐你使用 webrtc 播放来测试 zlm 延时；也可以用 ffplay 测试：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>ffplay <span class="token parameter variable">-i</span> rtmp://xxxxxxx <span class="token parameter variable">-fflags</span> nobuffer
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,2)),t("p",null,[e[3]||(e[3]=r("如果你不知道 ffplay 怎么安装，你可以从")),t("a",h,[e[2]||(e[2]=r("这里")),a(n)]),e[4]||(e[4]=r("下载编译好的."))]),e[9]||(e[9]=t("h2",{id:"关于延时的更多信息",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#关于延时的更多信息","aria-hidden":"true"},"#"),r(" 关于延时的更多信息")],-1)),t("p",null,[a(s,{to:"/zh/reference/documents/the_nature_of_live_broadcast_delay.html"},{default:l(()=>e[5]||(e[5]=[r("直播延时的本质")])),_:1})]),t("p",null,[a(s,{to:"/zh/reference/test/delay_test.html"},{default:l(()=>e[6]||(e[6]=[r("延时相关测试")])),_:1})])])}const L=p(u,[["render",m],["__file","how_to_test_delay.html.vue"]]);export{L as default};
